# Frontend Security Best Practices and Vulnerability Prevention

Frontend security is critical for protecting users and applications from various attacks. This comprehensive guide covers common vulnerabilities, prevention techniques, and security best practices for modern web applications.

## Common Frontend Vulnerabilities

### 1. Cross-Site Scripting (XSS)

**Types of XSS Attacks:**
- **Stored XSS** - Malicious script stored on server
- **Reflected XSS** - Script reflected from URL parameters
- **DOM-based XSS** - Client-side script manipulation

**XSS Prevention Techniques:**
```typescript
// 1. Input Sanitization and Validation
import DOMPurify from 'dompurify';
import { z } from 'zod';

// Server-side validation schema
const UserInputSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name too long')
    .regex(/^[a-zA-Z\s]*$/, 'Only letters and spaces allowed'),
  email: z.string().email('Invalid email format'),
  message: z.string()
    .min(1, 'Message is required')
    .max(1000, 'Message too long')
});

// Sanitize HTML content before rendering
function sanitizeHTML(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
    ALLOWED_ATTR: [],
  });
}

// Safe HTML rendering component
interface SafeHTMLProps {
  content: string;
  allowedTags?: string[];
}

const SafeHTML: React.FC<SafeHTMLProps> = ({ 
  content, 
  allowedTags = ['b', 'i', 'em', 'strong', 'p', 'br'] 
}) => {
  const sanitizedContent = useMemo(() => {
    return DOMPurify.sanitize(content, {
      ALLOWED_TAGS: allowedTags,
      ALLOWED_ATTR: [],
    });
  }, [content, allowedTags]);

  return (
    <div 
      dangerouslySetInnerHTML={{ __html: sanitizedContent }}
      className="prose"
    />
  );
};

// 2. Proper HTML Escaping
// React automatically escapes content, but be careful with dangerouslySetInnerHTML
const UserComment: React.FC<{ comment: Comment }> = ({ comment }) => {
  return (
    <div className="comment">
      {/* Safe - React automatically escapes */}
      <h4>{comment.author}</h4>
      <p>{comment.text}</p>
      
      {/* Dangerous - requires sanitization */}
      {comment.htmlContent && (
        <SafeHTML content={comment.htmlContent} />
      )}
      
      {/* Never do this without sanitization */}
      {/* <div dangerouslySetInnerHTML={{ __html: comment.rawHtml }} /> */}
    </div>
  );
};

// 3. URL Validation and Sanitization
function isValidURL(url: string): boolean {
  try {
    const urlObj = new URL(url);
    // Only allow safe protocols
    return ['http:', 'https:', 'mailto:'].includes(urlObj.protocol);
  } catch {
    return false;
  }
}

function sanitizeURL(url: string): string {
  if (!isValidURL(url)) {
    return '#';
  }
  
  // Prevent javascript: and data: URLs
  const urlObj = new URL(url);
  if (['javascript:', 'data:', 'vbscript:'].includes(urlObj.protocol)) {
    return '#';
  }
  
  return url;
}

// Safe link component
const SafeLink: React.FC<{ href: string; children: React.ReactNode }> = ({ 
  href, 
  children 
}) => {
  const safeHref = sanitizeURL(href);
  
  return (
    <a 
      href={safeHref} 
      target="_blank" 
      rel="noopener noreferrer"
      className="text-blue-600 hover:underline"
    >
      {children}
    </a>
  );
};

// 4. CSP (Content Security Policy) Headers
// next.config.js
const ContentSecurityPolicy = `
  default-src 'self';
  script-src 'self' 'unsafe-eval' 'unsafe-inline' https://vercel.live;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
  img-src 'self' blob: data: https://res.cloudinary.com;
  font-src 'self' https://fonts.gstatic.com;
  connect-src 'self' https://api.example.com;
  frame-src 'none';
  object-src 'none';
  base-uri 'self';
  form-action 'self';
  frame-ancestors 'none';
  upgrade-insecure-requests;
`;

const securityHeaders = [
  {
    key: 'Content-Security-Policy',
    value: ContentSecurityPolicy.replace(/\s{2,}/g, ' ').trim()
  },
  {
    key: 'X-Frame-Options',
    value: 'DENY'
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff'
  },
  {
    key: 'Referrer-Policy',
    value: 'origin-when-cross-origin'
  },
  {
    key: 'Permissions-Policy',
    value: 'camera=(), microphone=(), geolocation=()'
  }
];

module.exports = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: securityHeaders,
      },
    ];
  },
};
```

### 2. Cross-Site Request Forgery (CSRF)

**CSRF Prevention:**
```typescript
// 1. CSRF Token Implementation
import { randomBytes } from 'crypto';

// Generate CSRF token
function generateCSRFToken(): string {
  return randomBytes(32).toString('hex');
}

// Middleware to add CSRF token to forms
const withCSRFProtection = (handler: any) => {
  return async (req: any, res: any) => {
    if (req.method === 'GET') {
      // Generate and store CSRF token
      const csrfToken = generateCSRFToken();
      req.session.csrfToken = csrfToken;
      res.locals.csrfToken = csrfToken;
    } else if (['POST', 'PUT', 'DELETE'].includes(req.method)) {
      // Validate CSRF token
      const tokenFromBody = req.body._csrf;
      const tokenFromSession = req.session.csrfToken;
      
      if (!tokenFromBody || tokenFromBody !== tokenFromSession) {
        return res.status(403).json({ error: 'CSRF token validation failed' });
      }
    }
    
    return handler(req, res);
  };
};

// React form component with CSRF token
interface CSRFFormProps {
  action: string;
  method: string;
  children: React.ReactNode;
  onSubmit?: (e: React.FormEvent) => void;
}

const CSRFForm: React.FC<CSRFFormProps> = ({ 
  action, 
  method, 
  children, 
  onSubmit 
}) => {
  const [csrfToken, setCSRFToken] = useState<string>('');

  useEffect(() => {
    // Fetch CSRF token from server
    fetch('/api/csrf-token')
      .then(res => res.json())
      .then(data => setCSRFToken(data.token));
  }, []);

  return (
    <form action={action} method={method} onSubmit={onSubmit}>
      <input type="hidden" name="_csrf" value={csrfToken} />
      {children}
    </form>
  );
};

// 2. SameSite Cookie Configuration
const sessionConfig = {
  name: 'sessionId',
  secret: process.env.SESSION_SECRET,
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict' as const, // Prevents CSRF attacks
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
  },
  resave: false,
  saveUninitialized: false,
};

// 3. Double Submit Cookie Pattern
const generateDoubleSubmitToken = (): string => {
  return randomBytes(32).toString('hex');
};

const validateDoubleSubmitToken = (req: any): boolean => {
  const tokenFromCookie = req.cookies['csrf-token'];
  const tokenFromHeader = req.headers['x-csrf-token'];
  
  return tokenFromCookie && tokenFromHeader && tokenFromCookie === tokenFromHeader;
};

// Axios interceptor for automatic CSRF token inclusion
axios.interceptors.request.use(
  (config) => {
    const token = getCookie('csrf-token');
    if (token && ['post', 'put', 'delete'].includes(config.method?.toLowerCase() || '')) {
      config.headers['X-CSRF-Token'] = token;
    }
    return config;
  },
  (error) => Promise.reject(error)
);
```

### 3. Authentication and Session Security

**Secure Authentication Implementation:**
```typescript
// 1. Secure Password Handling
import bcrypt from 'bcryptjs';
import { z } from 'zod';

// Strong password validation
const PasswordSchema = z.string()
  .min(8, 'Password must be at least 8 characters')
  .regex(/[A-Z]/, 'Password must contain uppercase letter')
  .regex(/[a-z]/, 'Password must contain lowercase letter')
  .regex(/[0-9]/, 'Password must contain number')
  .regex(/[^A-Za-z0-9]/, 'Password must contain special character');

// Secure password hashing
const hashPassword = async (password: string): Promise<string> => {
  const saltRounds = 12; // High cost factor
  return bcrypt.hash(password, saltRounds);
};

const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};

// 2. JWT Security Best Practices
import jwt from 'jsonwebtoken';

interface JWTPayload {
  userId: string;
  email: string;
  roles: string[];
  iat: number;
  exp: number;
}

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;

// Secure JWT generation
const generateTokenPair = (user: User) => {
  const payload = {
    userId: user.id,
    email: user.email,
    roles: user.roles,
  };

  const accessToken = jwt.sign(payload, JWT_SECRET, {
    expiresIn: '15m', // Short-lived access token
    issuer: 'your-app',
    audience: 'your-app-users',
    algorithm: 'HS256',
  });

  const refreshToken = jwt.sign(
    { userId: user.id },
    JWT_REFRESH_SECRET,
    {
      expiresIn: '7d', // Longer-lived refresh token
      issuer: 'your-app',
      audience: 'your-app-users',
      algorithm: 'HS256',
    }
  );

  return { accessToken, refreshToken };
};

// JWT verification with proper error handling
const verifyAccessToken = (token: string): JWTPayload | null => {
  try {
    return jwt.verify(token, JWT_SECRET, {
      issuer: 'your-app',
      audience: 'your-app-users',
    }) as JWTPayload;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new Error('Token expired');
    } else if (error instanceof jwt.JsonWebTokenError) {
      throw new Error('Invalid token');
    } else {
      throw new Error('Token verification failed');
    }
  }
};

// 3. Secure Session Management
interface SessionData {
  userId: string;
  email: string;
  roles: string[];
  createdAt: Date;
  lastActivity: Date;
  ipAddress: string;
  userAgent: string;
}

class SecureSessionManager {
  private sessions = new Map<string, SessionData>();
  private readonly SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
  private readonly MAX_SESSIONS_PER_USER = 5;

  createSession(user: User, req: any): string {
    const sessionId = this.generateSecureSessionId();
    const sessionData: SessionData = {
      userId: user.id,
      email: user.email,
      roles: user.roles,
      createdAt: new Date(),
      lastActivity: new Date(),
      ipAddress: req.ip,
      userAgent: req.get('User-Agent') || '',
    };

    // Limit concurrent sessions per user
    this.cleanupUserSessions(user.id);
    this.sessions.set(sessionId, sessionData);

    return sessionId;
  }

  validateSession(sessionId: string, req: any): SessionData | null {
    const session = this.sessions.get(sessionId);
    
    if (!session) {
      return null;
    }

    // Check session timeout
    const now = new Date();
    if (now.getTime() - session.lastActivity.getTime() > this.SESSION_TIMEOUT) {
      this.sessions.delete(sessionId);
      return null;
    }

    // Verify IP address (optional, can be problematic with NAT)
    if (session.ipAddress !== req.ip && process.env.STRICT_IP_CHECK === 'true') {
      this.sessions.delete(sessionId);
      return null;
    }

    // Update last activity
    session.lastActivity = now;
    return session;
  }

  destroySession(sessionId: string): void {
    this.sessions.delete(sessionId);
  }

  destroyAllUserSessions(userId: string): void {
    for (const [sessionId, session] of this.sessions) {
      if (session.userId === userId) {
        this.sessions.delete(sessionId);
      }
    }
  }

  private generateSecureSessionId(): string {
    return randomBytes(32).toString('hex');
  }

  private cleanupUserSessions(userId: string): void {
    const userSessions = Array.from(this.sessions.entries())
      .filter(([_, session]) => session.userId === userId)
      .sort(([_, a], [__, b]) => b.lastActivity.getTime() - a.lastActivity.getTime());

    // Keep only the most recent sessions
    if (userSessions.length >= this.MAX_SESSIONS_PER_USER) {
      const sessionsToRemove = userSessions.slice(this.MAX_SESSIONS_PER_USER - 1);
      sessionsToRemove.forEach(([sessionId]) => {
        this.sessions.delete(sessionId);
      });
    }
  }
}

// React authentication context with security features
interface AuthContextType {
  user: User | null;
  login: (email: string, password: string, rememberMe?: boolean) => Promise<void>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<void>;
  loading: boolean;
  error: string | null;
}

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Automatic token refresh
  useEffect(() => {
    const refreshInterval = setInterval(async () => {
      try {
        await refreshToken();
      } catch (error) {
        // Token refresh failed, logout user
        await logout();
      }
    }, 14 * 60 * 1000); // Refresh every 14 minutes

    return () => clearInterval(refreshInterval);
  }, []);

  // Session timeout warning
  useEffect(() => {
    let timeoutId: NodeJS.Timeout;
    let warningId: NodeJS.Timeout;

    const resetTimeout = () => {
      clearTimeout(timeoutId);
      clearTimeout(warningId);

      // Show warning 2 minutes before timeout
      warningId = setTimeout(() => {
        const shouldExtend = confirm('Your session will expire soon. Extend session?');
        if (shouldExtend) {
          refreshToken();
        }
      }, 28 * 60 * 1000); // 28 minutes

      // Auto logout after 30 minutes
      timeoutId = setTimeout(() => {
        logout();
      }, 30 * 60 * 1000); // 30 minutes
    };

    const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];
    
    const resetTimeoutOnActivity = () => resetTimeout();
    
    events.forEach(event => {
      document.addEventListener(event, resetTimeoutOnActivity, true);
    });

    resetTimeout();

    return () => {
      clearTimeout(timeoutId);
      clearTimeout(warningId);
      events.forEach(event => {
        document.removeEventListener(event, resetTimeoutOnActivity, true);
      });
    };
  }, [user]);

  const login = async (email: string, password: string, rememberMe = false) => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password, rememberMe }),
        credentials: 'include',
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Login failed');
      }

      const { accessToken, user } = await response.json();
      
      // Store access token securely
      if (rememberMe) {
        localStorage.setItem('accessToken', accessToken);
      } else {
        sessionStorage.setItem('accessToken', accessToken);
      }

      setUser(user);
    } catch (error) {
      setError(error.message);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const logout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include',
      });
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      localStorage.removeItem('accessToken');
      sessionStorage.removeItem('accessToken');
      setUser(null);
    }
  };

  const refreshToken = async () => {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include',
      });

      if (!response.ok) {
        throw new Error('Token refresh failed');
      }

      const { accessToken } = await response.json();
      
      const currentToken = localStorage.getItem('accessToken') || sessionStorage.getItem('accessToken');
      if (currentToken) {
        if (localStorage.getItem('accessToken')) {
          localStorage.setItem('accessToken', accessToken);
        } else {
          sessionStorage.setItem('accessToken', accessToken);
        }
      }
    } catch (error) {
      throw new Error('Token refresh failed');
    }
  };

  return (
    <AuthContext.Provider value={{
      user,
      login,
      logout,
      refreshToken,
      loading,
      error,
    }}>
      {children}
    </AuthContext.Provider>
  );
};
```

### 4. Secure API Communication

**API Security Best Practices:**
```typescript
// 1. Secure HTTP Client Configuration
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';

// Create secure axios instance
const createSecureApiClient = () => {
  const client = axios.create({
    baseURL: process.env.NEXT_PUBLIC_API_URL,
    timeout: 10000,
    withCredentials: true,
    headers: {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest', // CSRF protection
    },
  });

  // Request interceptor for authentication
  client.interceptors.request.use(
    (config: AxiosRequestConfig) => {
      // Add auth token
      const token = getAuthToken();
      if (token) {
        config.headers = {
          ...config.headers,
          Authorization: `Bearer ${token}`,
        };
      }

      // Add CSRF token
      const csrfToken = getCSRFToken();
      if (csrfToken && ['post', 'put', 'delete'].includes(config.method?.toLowerCase() || '')) {
        config.headers = {
          ...config.headers,
          'X-CSRF-Token': csrfToken,
        };
      }

      return config;
    },
    (error) => Promise.reject(error)
  );

  // Response interceptor for error handling and token refresh
  client.interceptors.response.use(
    (response: AxiosResponse) => response,
    async (error) => {
      const originalRequest = error.config;

      // Handle 401 Unauthorized
      if (error.response?.status === 401 && !originalRequest._retry) {
        originalRequest._retry = true;

        try {
          await refreshAuthToken();
          const newToken = getAuthToken();
          originalRequest.headers.Authorization = `Bearer ${newToken}`;
          return client(originalRequest);
        } catch (refreshError) {
          // Refresh failed, redirect to login
          window.location.href = '/login';
          return Promise.reject(refreshError);
        }
      }

      // Handle 403 Forbidden
      if (error.response?.status === 403) {
        // Redirect to unauthorized page or show error
        window.location.href = '/unauthorized';
      }

      return Promise.reject(error);
    }
  );

  return client;
};

// 2. Input Validation and Sanitization
import { z } from 'zod';

// API endpoint with validation
const ApiEndpoints = {
  createUser: '/api/users',
  getUser: (id: string) => `/api/users/${encodeURIComponent(id)}`,
  updateUser: (id: string) => `/api/users/${encodeURIComponent(id)}`,
  deleteUser: (id: string) => `/api/users/${encodeURIComponent(id)}`,
} as const;

// Validation schemas
const CreateUserSchema = z.object({
  name: z.string().min(1).max(100).trim(),
  email: z.string().email().toLowerCase(),
  age: z.number().int().min(13).max(120),
  bio: z.string().max(500).optional(),
});

const UpdateUserSchema = CreateUserSchema.partial();

// Secure API service class
class UserApiService {
  private client = createSecureApiClient();

  async createUser(userData: unknown) {
    // Validate input
    const validatedData = CreateUserSchema.parse(userData);
    
    try {
      const response = await this.client.post(ApiEndpoints.createUser, validatedData);
      return response.data;
    } catch (error) {
      this.handleApiError(error);
      throw error;
    }
  }

  async getUser(id: string) {
    // Validate ID format
    if (!id || typeof id !== 'string' || id.length > 50) {
      throw new Error('Invalid user ID');
    }

    try {
      const response = await this.client.get(ApiEndpoints.getUser(id));
      return response.data;
    } catch (error) {
      this.handleApiError(error);
      throw error;
    }
  }

  async updateUser(id: string, userData: unknown) {
    const validatedData = UpdateUserSchema.parse(userData);
    
    try {
      const response = await this.client.patch(
        ApiEndpoints.updateUser(id), 
        validatedData
      );
      return response.data;
    } catch (error) {
      this.handleApiError(error);
      throw error;
    }
  }

  private handleApiError(error: any) {
    // Log security-relevant errors
    if (error.response?.status === 401) {
      console.warn('Unauthorized API request detected');
    } else if (error.response?.status === 403) {
      console.warn('Forbidden API request detected');
    } else if (error.response?.status >= 500) {
      console.error('Server error:', error.response.data);
    }

    // Don't expose internal error details to client
    if (error.response?.status >= 500) {
      throw new Error('An unexpected error occurred. Please try again.');
    }
  }
}

// 3. Rate Limiting Implementation
class RateLimiter {
  private requests = new Map<string, number[]>();
  private readonly maxRequests: number;
  private readonly windowMs: number;

  constructor(maxRequests = 100, windowMs = 15 * 60 * 1000) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
  }

  isAllowed(identifier: string): boolean {
    const now = Date.now();
    const userRequests = this.requests.get(identifier) || [];
    
    // Remove old requests outside the window
    const validRequests = userRequests.filter(time => now - time < this.windowMs);
    
    if (validRequests.length >= this.maxRequests) {
      return false;
    }

    // Add current request
    validRequests.push(now);
    this.requests.set(identifier, validRequests);
    
    return true;
  }

  getRemainingRequests(identifier: string): number {
    const userRequests = this.requests.get(identifier) || [];
    const now = Date.now();
    const validRequests = userRequests.filter(time => now - time < this.windowMs);
    
    return Math.max(0, this.maxRequests - validRequests.length);
  }
}

// Usage in React hooks
const useRateLimitedApi = () => {
  const rateLimiter = useRef(new RateLimiter(10, 60000)); // 10 requests per minute
  const userApiService = useRef(new UserApiService());

  const makeRequest = useCallback(async (requestFn: () => Promise<any>) => {
    const userId = getCurrentUserId();
    
    if (!rateLimiter.current.isAllowed(userId)) {
      throw new Error('Rate limit exceeded. Please try again later.');
    }

    return requestFn();
  }, []);

  return {
    createUser: (userData: unknown) => 
      makeRequest(() => userApiService.current.createUser(userData)),
    getUser: (id: string) => 
      makeRequest(() => userApiService.current.getUser(id)),
    updateUser: (id: string, userData: unknown) => 
      makeRequest(() => userApiService.current.updateUser(id, userData)),
  };
};
```

## OWASP Top 10 Frontend Considerations

### 1. Injection Prevention
```typescript
// SQL Injection prevention (for full-stack developers)
import { z } from 'zod';

// Always use parameterized queries, never string concatenation
const getUserById = async (id: string) => {
  // ❌ DANGEROUS - SQL Injection vulnerability
  // const query = `SELECT * FROM users WHERE id = '${id}'`;
  
  // ✅ SAFE - Parameterized query
  const query = 'SELECT * FROM users WHERE id = $1';
  const result = await db.query(query, [id]);
  return result.rows[0];
};

// NoSQL Injection prevention
const findUserByEmail = async (email: string) => {
  // Validate input
  const EmailSchema = z.string().email();
  const validEmail = EmailSchema.parse(email);
  
  // ❌ DANGEROUS
  // const user = await User.findOne({ email: email });
  
  // ✅ SAFE - Explicit object construction
  const user = await User.findOne({ 
    email: { $eq: validEmail } 
  });
  return user;
};

// Command Injection prevention
const processUserUpload = async (filename: string) => {
  // Validate filename
  const FilenameSchema = z.string()
    .regex(/^[a-zA-Z0-9._-]+$/, 'Invalid filename')
    .max(255);
  
  const validFilename = FilenameSchema.parse(filename);
  
  // ❌ DANGEROUS
  // exec(`convert ${filename} output.jpg`);
  
  // ✅ SAFE - Use arrays instead of shell commands
  const { spawn } = require('child_process');
  const convert = spawn('convert', [validFilename, 'output.jpg']);
};
```

### 2. Broken Authentication Prevention
```typescript
// Multi-factor authentication implementation
import { authenticator } from 'otplib';
import QRCode from 'qrcode';

class MFAService {
  generateSecret(userEmail: string): { secret: string; qrCode: string } {
    const secret = authenticator.generateSecret();
    const service = 'YourApp';
    const otpauth = authenticator.keyuri(userEmail, service, secret);
    
    return {
      secret,
      qrCode: QRCode.toDataURL(otpauth),
    };
  }

  verifyToken(token: string, secret: string): boolean {
    return authenticator.verify({ token, secret });
  }

  generateBackupCodes(): string[] {
    return Array.from({ length: 10 }, () => 
      randomBytes(4).toString('hex').toUpperCase()
    );
  }
}

// Account lockout after failed attempts
class AccountSecurity {
  private failedAttempts = new Map<string, {
    count: number;
    lastAttempt: Date;
    lockedUntil?: Date;
  }>();

  recordFailedLogin(email: string): void {
    const now = new Date();
    const attempts = this.failedAttempts.get(email) || { count: 0, lastAttempt: now };
    
    // Reset count if last attempt was over an hour ago
    if (now.getTime() - attempts.lastAttempt.getTime() > 60 * 60 * 1000) {
      attempts.count = 0;
    }

    attempts.count++;
    attempts.lastAttempt = now;

    // Lock account after 5 failed attempts
    if (attempts.count >= 5) {
      attempts.lockedUntil = new Date(now.getTime() + 30 * 60 * 1000); // 30 minutes
    }

    this.failedAttempts.set(email, attempts);
  }

  isAccountLocked(email: string): boolean {
    const attempts = this.failedAttempts.get(email);
    if (!attempts?.lockedUntil) return false;
    
    return new Date() < attempts.lockedUntil;
  }

  clearFailedAttempts(email: string): void {
    this.failedAttempts.delete(email);
  }
}
```

### 3. Sensitive Data Exposure Prevention
```typescript
// Data encryption utilities
import CryptoJS from 'crypto-js';

class DataEncryption {
  private key: string;

  constructor() {
    this.key = process.env.ENCRYPTION_KEY!;
    if (!this.key) {
      throw new Error('Encryption key not configured');
    }
  }

  encrypt(data: string): string {
    return CryptoJS.AES.encrypt(data, this.key).toString();
  }

  decrypt(encryptedData: string): string {
    const bytes = CryptoJS.AES.decrypt(encryptedData, this.key);
    return bytes.toString(CryptoJS.enc.Utf8);
  }

  hash(data: string): string {
    return CryptoJS.SHA256(data).toString();
  }
}

// Secure local storage wrapper
class SecureStorage {
  private encryption = new DataEncryption();

  setItem(key: string, value: any): void {
    try {
      const stringValue = JSON.stringify(value);
      const encryptedValue = this.encryption.encrypt(stringValue);
      localStorage.setItem(key, encryptedValue);
    } catch (error) {
      console.error('Failed to store encrypted data:', error);
    }
  }

  getItem<T>(key: string): T | null {
    try {
      const encryptedValue = localStorage.getItem(key);
      if (!encryptedValue) return null;
      
      const decryptedValue = this.encryption.decrypt(encryptedValue);
      return JSON.parse(decryptedValue);
    } catch (error) {
      console.error('Failed to retrieve encrypted data:', error);
      return null;
    }
  }

  removeItem(key: string): void {
    localStorage.removeItem(key);
  }

  clear(): void {
    localStorage.clear();
  }
}

// PII (Personally Identifiable Information) handling
interface UserPII {
  email: string;
  phone?: string;
  ssn?: string;
  creditCard?: string;
}

class PIIHandler {
  private encryption = new DataEncryption();

  // Mask sensitive data for display
  maskEmail(email: string): string {
    const [username, domain] = email.split('@');
    const maskedUsername = username.length > 2 
      ? username.slice(0, 2) + '*'.repeat(username.length - 2)
      : username;
    return `${maskedUsername}@${domain}`;
  }

  maskPhone(phone: string): string {
    return phone.replace(/(\d{3})\d{3}(\d{4})/, '$1***$2');
  }

  maskCreditCard(cardNumber: string): string {
    return cardNumber.replace(/\d{12}(\d{4})/, '************$1');
  }

  // Encrypt PII before storage
  encryptPII(pii: UserPII): any {
    return {
      email: this.encryption.encrypt(pii.email),
      phone: pii.phone ? this.encryption.encrypt(pii.phone) : undefined,
      ssn: pii.ssn ? this.encryption.encrypt(pii.ssn) : undefined,
      creditCard: pii.creditCard ? this.encryption.encrypt(pii.creditCard) : undefined,
    };
  }

  // Log access to sensitive data
  logDataAccess(userId: string, dataType: string, action: string): void {
    console.log(`[AUDIT] User ${userId} ${action} ${dataType} at ${new Date().toISOString()}`);
    
    // In production, send to audit log service
    // auditLogger.log({
    //   userId,
    //   dataType,
    //   action,
    //   timestamp: new Date(),
    //   ipAddress: getCurrentIP(),
    //   userAgent: getCurrentUserAgent(),
    // });
  }
}
```

## Secure Development Practices

### 1. Security Headers Implementation
```typescript
// Security headers middleware for Next.js
export function securityHeaders() {
  return [
    {
      key: 'X-DNS-Prefetch-Control',
      value: 'on'
    },
    {
      key: 'Strict-Transport-Security',
      value: 'max-age=63072000; includeSubDomains; preload'
    },
    {
      key: 'X-XSS-Protection',
      value: '1; mode=block'
    },
    {
      key: 'X-Frame-Options',
      value: 'SAMEORIGIN'
    },
    {
      key: 'Permissions-Policy',
      value: 'camera=(), microphone=(), geolocation=(), interest-cohort=()'
    },
    {
      key: 'X-Content-Type-Options',
      value: 'nosniff'
    },
    {
      key: 'Referrer-Policy',
      value: 'origin-when-cross-origin'
    },
    {
      key: 'Content-Security-Policy',
      value: ContentSecurityPolicy.replace(/\s{2,}/g, ' ').trim()
    }
  ];
}

// Content Security Policy builder
class CSPBuilder {
  private directives: Record<string, string[]> = {};

  addDirective(directive: string, sources: string[]): this {
    this.directives[directive] = sources;
    return this;
  }

  build(): string {
    return Object.entries(this.directives)
      .map(([directive, sources]) => `${directive} ${sources.join(' ')}`)
      .join('; ');
  }

  static createDefault(): CSPBuilder {
    return new CSPBuilder()
      .addDirective('default-src', ["'self'"])
      .addDirective('script-src', ["'self'", "'unsafe-eval'"])
      .addDirective('style-src', ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'])
      .addDirective('img-src', ["'self'", 'blob:', 'data:', 'https:'])
      .addDirective('font-src', ["'self'", 'https://fonts.gstatic.com'])
      .addDirective('connect-src', ["'self'"])
      .addDirective('frame-src', ["'none'"])
      .addDirective('object-src', ["'none'"])
      .addDirective('base-uri', ["'self'"])
      .addDirective('form-action', ["'self'"]);
  }
}
```

### 2. Secure Development Checklist
```typescript
// Security audit checklist implementation
interface SecurityCheckResult {
  check: string;
  passed: boolean;
  message: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

class SecurityAuditor {
  async auditApplication(): Promise<SecurityCheckResult[]> {
    const results: SecurityCheckResult[] = [];

    // Check for hardcoded secrets
    results.push(await this.checkHardcodedSecrets());
    
    // Check authentication implementation
    results.push(await this.checkAuthentication());
    
    // Check input validation
    results.push(await this.checkInputValidation());
    
    // Check HTTPS usage
    results.push(await this.checkHTTPS());
    
    // Check dependency vulnerabilities
    results.push(await this.checkDependencies());

    return results;
  }

  private async checkHardcodedSecrets(): Promise<SecurityCheckResult> {
    // In a real implementation, this would scan code for secrets
    const hasHardcodedSecrets = false; // Placeholder
    
    return {
      check: 'Hardcoded Secrets',
      passed: !hasHardcodedSecrets,
      message: hasHardcodedSecrets 
        ? 'Hardcoded secrets found in code'
        : 'No hardcoded secrets detected',
      severity: 'critical'
    };
  }

  private async checkAuthentication(): Promise<SecurityCheckResult> {
    const hasSecureAuth = process.env.JWT_SECRET && process.env.JWT_SECRET.length >= 32;
    
    return {
      check: 'Authentication Security',
      passed: hasSecureAuth,
      message: hasSecureAuth
        ? 'Authentication properly configured'
        : 'Weak or missing authentication configuration',
      severity: 'high'
    };
  }

  private async checkInputValidation(): Promise<SecurityCheckResult> {
    // Check if validation library is installed
    const hasValidation = true; // Placeholder
    
    return {
      check: 'Input Validation',
      passed: hasValidation,
      message: hasValidation
        ? 'Input validation implemented'
        : 'Missing input validation',
      severity: 'high'
    };
  }

  private async checkHTTPS(): Promise<SecurityCheckResult> {
    const isHTTPS = process.env.NODE_ENV === 'production' 
      ? window.location.protocol === 'https:'
      : true;
    
    return {
      check: 'HTTPS Usage',
      passed: isHTTPS,
      message: isHTTPS
        ? 'HTTPS properly configured'
        : 'HTTPS not configured for production',
      severity: 'high'
    };
  }

  private async checkDependencies(): Promise<SecurityCheckResult> {
    // In real implementation, integrate with npm audit or similar
    const hasVulnerabilities = false; // Placeholder
    
    return {
      check: 'Dependency Vulnerabilities',
      passed: !hasVulnerabilities,
      message: hasVulnerabilities
        ? 'Vulnerable dependencies detected'
        : 'No known vulnerabilities in dependencies',
      severity: 'medium'
    };
  }
}

// Security testing utilities
class SecurityTester {
  testXSSPrevention(input: string): boolean {
    const maliciousInputs = [
      '<script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      'onload="alert(\'XSS\')"',
      '<img src="x" onerror="alert(\'XSS\')">'
    ];

    // Test if input is properly sanitized
    return !maliciousInputs.some(malicious => 
      input.includes(malicious)
    );
  }

  testCSRFProtection(): boolean {
    // Check if CSRF token is present in forms
    const forms = document.querySelectorAll('form');
    return Array.from(forms).every(form => 
      form.querySelector('input[name="_csrf"]') !== null
    );
  }

  testPasswordStrength(password: string): {
    score: number;
    feedback: string[];
  } {
    const feedback: string[] = [];
    let score = 0;

    if (password.length >= 8) score++;
    else feedback.push('Use at least 8 characters');

    if (/[A-Z]/.test(password)) score++;
    else feedback.push('Include uppercase letters');

    if (/[a-z]/.test(password)) score++;
    else feedback.push('Include lowercase letters');

    if (/[0-9]/.test(password)) score++;
    else feedback.push('Include numbers');

    if (/[^A-Za-z0-9]/.test(password)) score++;
    else feedback.push('Include special characters');

    return { score, feedback };
  }
}
```

## Interview-Ready Summary

**Frontend Security requires:**

1. **XSS Prevention** - Input sanitization, CSP headers, safe HTML rendering, URL validation
2. **CSRF Protection** - CSRF tokens, SameSite cookies, double submit patterns
3. **Authentication Security** - Secure password handling, JWT best practices, session management
4. **Secure Communication** - HTTPS enforcement, input validation, rate limiting, secure headers
5. **Data Protection** - Encryption, secure storage, PII handling, audit logging

**Key security principles:**
- **Defense in depth** - Multiple security layers
- **Least privilege** - Minimal required access
- **Input validation** - Never trust user input
- **Secure by default** - Safe default configurations
- **Regular audits** - Continuous security assessment

**Common vulnerabilities:** XSS, CSRF, injection attacks, broken authentication, sensitive data exposure, security misconfigurations, insufficient logging.

**Best practices:** Use security headers, implement proper authentication, validate all inputs, encrypt sensitive data, audit dependencies, follow OWASP guidelines, conduct regular security testing.